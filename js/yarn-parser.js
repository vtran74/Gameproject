function captureSquareBrackets(line)
{
  //Find the string "[[...]]" and capture its content
  var regExp = /\[\[(.*?)\]\]/i;
  var capture = regExp.exec(line);
  //Build a new choice target that will be populated
  var choice = {"target":"", "text":"", "conditions":[]};


  if(capture == null)
  {
    return false;
  } else 
  {
    //The next node text and identifier are inside [[here]]
    //Split them at the | character
    var data = capture[1].split('|');
    var choice = {"target":"", "text":""};

    choice.text = data[0].trim();
    if(data.length > 1)
    {
      choice.target = data[1].trim().toLowerCase();
    }
    return choice;
  }
}

function captureAngleBrackets(line)
{
  //Find "<<... ...>>", perhaps multiples times.
  //These are logic blocks, that can be conditions or actions.
  //(aka "things to do", or "checking if some things are done")
  //Capture their names and options.
  var regExp = /(\<\<(.*?) (.*?)\>\>)+/g;

  var match;
  var blocks = [];
  //Keep searching until there's no match left
  while((match = regExp.exec(line)) != null)
  {
    blocks.push({
      "type":match[2],
      "options":match[3].split(' ')
    });
  }
  return blocks;
}

function captureCurlyBrackets(line)
{
  //Find "{{...,...}}" or "{{...}}"
  //These are character blocks, defining which character speaks
  //and in what pose they are (which sprite they'll be represented, usually)
  var regExp = /(\{\{(.*?)\}\})+/g;
  var capture = regExp.exec(line);

  var characterData = {"id":"", "pose":"default"};

  if(capture == null)
  {
    return false;
  } else 
  {
    //The character id and its optional pose are written as
    //{{id,pose}} or simply {{id}}
    var data = capture[2].split(',');
    characterData.id = data[0].trim().toLowerCase();
    if(data.length > 1)
    {
      characterData.pose = data[1].trim().toLowerCase();
    }
  }
  return characterData;
}

function parseStory()
{
  var autoIncrement = 0;
  //For every node
  for(var node in story)
  {
    //Split the content into lines
    var lines = story[node].body.split('\n');
    //Split the tags at spaces
    var tags = story[node].tags.split(" ");

    //We have no scene to work with at first.
    //If a scene is kept between lines (for Actions or explicit choices),
    //this will hold the object for further use
    var currentScene = false;

    //This will be the name of the first scene we create in this node
    var firstSceneName = story[node].title;

    //For each line in this scene
    for(var l in lines)
    {
      var line = lines[l];
      line = line.trim()
      if (line.length == 0) continue; //Ignore empty lines
      if (line.substr(0,2) == "//") continue; //Ignore comments

      //Woops, special case here
      //After a choice group, if we go back to a single-choiced scene, we need to close the group first
      //Example:
      //
      //[[Some text]]
      //[[Some other text]]
      //And a regular scene
      //
      //both choices will then lead to the regular scene.
      if(currentScene != false && 
          currentScene.choices.length > 0 &&
          line.substr(0,2) != "[[")
      {
        for(var c in currentScene.choices)
        {
          //Generate implicit scene changes for choices that didn't specify a target
          if(currentScene.choices[c].target == "")
          {
            currentScene.choices[c].target = "autogenerated_"+autoIncrement;  
          }          
        }
        //Add the scene to the final list
        scenes[currentScene.id] = currentScene;
        //And reset the current scene so that we can generate a new one
        currentScene = false;  
      }

      //If we don't have a scene to work with
      if(!currentScene)
      {
        //Let's create one!
        currentScene = {
          "id":"",
          "choices":[],
          "actions":[],
          "character":false
        }

        //Do we have a name given by the node's title?
        if(firstSceneName)
        {
          //Then use it :3
          currentScene.id = story[node].title.trim().toLowerCase();
          //And reset it so that noone else does >:3
          firstSceneName = false;
        } else 
        {
          //Nope, we're in the middle of a node.
          //That means we just have to create a unique identifier,
          //It will only be linked to automatically, not referenced by any part of the story.
          currentScene.id = "autogenerated_"+autoIncrement;
          autoIncrement++;
        }
      }
    
      //Build a new choice that will be populated
      var choice = {"target":"", "text":"", "conditions":[]};
    
      //Parse the line for character data
      var characterData = captureCurlyBrackets(line);
      if(!characterData)
      {
        //No character data? Too bad, we'll add some default stuff then.
        characterData = {"id":"default", "pose":"hidden"};
      } else
      {
        //Remove the character data from the line to continue parsing it properly
        var characterRegExp = /(\{\{.*?\}\})+/g;
        line = line.replace(characterRegExp, "");
      }

      //Parse the line for explicit choicess
      var choiceData = captureSquareBrackets(line);
      //Parse the line for logic blocks (Actions/Conditions)
      var logicData = captureAngleBrackets(line);
      

      if(choiceData)
      {
        //Explicit choice! Exciting!
        choice.target = choiceData.target;
        choice.text = choiceData.text;

        //If this choice has Conditions, parse them all as well
        for(var c in logicData)
        {
          choice.conditions = logicData;
        }

        //Add the choice to the scene
        currentScene["choices"].push(choice);
        //Add the character data to the scene
        currentScene.character = characterData;

      } else if (logicData.length > 0)
      {
        //There's at least one Action block on this line!
        //Add it/them to the list of actions for the current scene
        currentScene.actions = currentScene.actions.concat(logicData);
        continue;
      } else
      {
        //No choice data, no Action. Boring.
        //Let's generate an implicit scene change.
        choice.target = "autogenerated_"+autoIncrement;
        choice.text = line.trim();

        //Add the choice to the scene
        currentScene["choices"].push(choice);
        //Add the character data to the scene
        currentScene.character = characterData;
        //Add the scene to the final list
        scenes[currentScene.id] = currentScene;
        //And reset the current scene so that we can generate a new one
        currentScene = false;
      }
      
    }

    //If we had a scene in the works, it's time
    //to commit it to the list
    if(currentScene)
    {
      scenes[currentScene.id] = currentScene;
    }
  }
}