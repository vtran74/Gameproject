function captureSquareBrackets(line)
{
  //Find "[[...]]" and capture its content
  var regExp = /\[\[(.*?)\]\]/i;
  var capture = regExp.exec(line);
  //Build a new choice target that will be populated
  var choice = {"target":"", "text":"", "conditions":[]};


  if(capture == null)
  {
    return false;
  } else 
  {
    //The next node text and identifier are inside [[here]]
    //they are split at the |
    var data = capture[1].split('|');
    var choice = {"target":"", "text":""};

    choice.text = data[0].trim();
    if(data.length > 1)
    {
      choice.target = data[1].trim().toLowerCase();
    }
    return choice;
  }
}

function captureAngleBrackets(line)
{
  //Find the "<<... ...>>"
  //use as conditons or actions
  //Capture their names and options.
  var regExp = /(\<\<(.*?) (.*?)\>\>)+/g;
  var match;
  var blocks = [];
  //Keep searching until no match left
  while((match = regExp.exec(line)) != null)
  {
    blocks.push({
      "type":match[2],
      "options":match[3].split(' ')
    });
  }
  return blocks;
}

function captureCurlyBrackets(line)
{
  //Find "{{...,...}}" or "{{...}}"
  //defines which character speaks
  //after comma is the pose the character is in
  var regExp = /(\{\{(.*?)\}\})+/g;
  var capture = regExp.exec(line);

  var characterData = {"id":"", "pose":"default"};

  if(capture == null)
  {
    return false;
  } else 
  {
    var data = capture[2].split(',');
    characterData.id = data[0].trim().toLowerCase();
    if(data.length > 1)
    {
      characterData.pose = data[1].trim().toLowerCase();
    }
  }
  return characterData;
}

function parseStory()
{
  var autoIncrement = 0;
  for(var node in story)
  {
    //Split content into lines
    var lines = story[node].body.split('\n');
    //Split  tags at spaces
    var tags = story[node].tags.split(" ");

    var currentScene = false;

    //name of the first scene created in this node
    var firstSceneName = story[node].title;

    //For each line in this scene
    for(var l in lines)
    {
      var line = lines[l];
      line = line.trim()
      if (line.length == 0) continue; //Ignore empty lines
      if (line.substr(0,2) == "//") continue; //Ignore comments
      if(currentScene != false && 
          currentScene.choices.length > 0 &&
          line.substr(0,2) != "[[")
      {
        for(var c in currentScene.choices)
        {
          //Generate implicit scene changes for choices that didn't specify a target
          if(currentScene.choices[c].target == "")
          {
            currentScene.choices[c].target = "autogenerated_"+autoIncrement;  
          }          
        }
        //Add the scene to the final list
        scenes[currentScene.id] = currentScene;
        //And reset the current scene so that we can generate a new one
        currentScene = false;  
      }

      //If no scene to work with
      if(!currentScene)
      {
        //this creates one
        currentScene = {
          "id":"",
          "choices":[],
          "actions":[],
          "character":false
        }

        //Do we have a name given by the node's title?
        if(firstSceneName)
        {
          currentScene.id = story[node].title.trim().toLowerCase();
          firstSceneName = false;
        } else 
        {
          currentScene.id = "autogenerated_"+autoIncrement;
          autoIncrement++;
        }
      }
    
      //Build a new choice that will be populated
      var choice = {"target":"", "text":"", "conditions":[]};
    
      //Parse the line for character data
      var characterData = captureCurlyBrackets(line);
      if(!characterData)
      {
        //add some default stuff if no character data.
        characterData = {"id":"default", "pose":"hidden"};
      } else
      {
        //Removes character data from the line to continue parsing it properly
        var characterRegExp = /(\{\{.*?\}\})+/g;
        line = line.replace(characterRegExp, "");
      }

      //Parses the line for explicit choicess
      var choiceData = captureSquareBrackets(line);
      //Parses the line for (Actions/Conditions)
      var logicData = captureAngleBrackets(line);
      

      if(choiceData)
      {
        choice.target = choiceData.target;
        choice.text = choiceData.text;

        for(var c in logicData)
        {
          choice.conditions = logicData;
        }

        //Add the choice to the scene
        currentScene["choices"].push(choice);
        //Add the character data to the scene
        currentScene.character = characterData;

      } else if (logicData.length > 0)
      {
        currentScene.actions = currentScene.actions.concat(logicData);
        continue;
      } else
      {
        //No choice data, no Action.
        //Generates an implicit scene change.
        choice.target = "autogenerated_"+autoIncrement;
        choice.text = line.trim();

        //Adds the choice to the scene
        currentScene["choices"].push(choice);
        //Adds the character data to the scene
        currentScene.character = characterData;
        //Adds the scene to the final list
        scenes[currentScene.id] = currentScene;
        //And resets the current scene so that new one can be generated
        currentScene = false;
      }
      
    }

    if(currentScene)
    {
      scenes[currentScene.id] = currentScene;
    }
  }
}
